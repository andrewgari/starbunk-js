version: 2.1

executors:
  node20:
    docker:
      - image: cimg/node:20.16
    resource_class: medium
  node22:
    docker:
      - image: cimg/node:22.7
    resource_class: medium
  docker:
    machine: true
    resource_class: medium

commands:
  setup_npm_cache:
    steps:
      - restore_cache:
          keys:
            - v1-npm-{{ arch }}-{{ .Branch }}-{{ checksum "package-lock.json" }}
            - v1-npm-{{ arch }}-{{ .Branch }}-
            - v1-npm-{{ arch }}-
      - run:
          name: Install dependencies
          command: npm ci
      - save_cache:
          key: v1-npm-{{ arch }}-{{ .Branch }}-{{ checksum "package-lock.json" }}
          paths:
            - ~/.npm
            - node_modules
  persist_build_artifacts:
    steps:
      - run:
          name: Compress build artifacts
          command: |
            tar -czf build-artifacts.tar.gz \
              src/*/dist/ \
              src/*/package.json \
              src/shared/node_modules/ \
              package.json \
              package-lock.json
      - persist_to_workspace:
          root: .
          paths:
            - build-artifacts.tar.gz
  attach_build_artifacts:
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Extract build artifacts
          command: tar -xzf build-artifacts.tar.gz

jobs:
  build_apps:
    executor: node20
    steps:
      - checkout
      - setup_npm_cache
      - run:
          name: Clean and build
          command: |
            npm run clean || true
            npm run build
      - persist_build_artifacts

  docker_build_and_validate_main:
    parameters:
      app:
        type: string
      dockerfile:
        type: string
    machine: true
    resource_class: medium
    steps:
      - checkout
      - attach_build_artifacts
      - run:
          name: Compute content hash
          command: |
            set -e
            APP="<< parameters.app >>"
            HASH=$(git rev-parse HEAD:src/${APP} 2>/dev/null || echo "no-hash")
            SHARED_HASH=$(git rev-parse HEAD:src/shared 2>/dev/null || echo "no-shared")
            DEPS_HASH=$(sha256sum package-lock.json | cut -d' ' -f1 | head -c 12)
            CONTENT_HASH="${HASH:0:12}-${SHARED_HASH:0:12}-${DEPS_HASH}"
            echo "${CONTENT_HASH}" > .circleci/${APP}.hash
      - run:
          name: Login to GHCR
          command: |
            echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USERNAME" --password-stdin
      - run:
          name: Check for existing sha image
          command: |
            set -e
            APP="<< parameters.app >>"
            HASH=$(cat .circleci/${APP}.hash)
            IMAGE="ghcr.io/${CIRCLE_PROJECT_USERNAME}/${APP}:sha-${HASH}"
            if docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
              echo "exists=true" > .circleci/${APP}.exists
              docker pull "$IMAGE"
              docker tag "$IMAGE" "ghcr.io/${CIRCLE_PROJECT_USERNAME}/${APP}:main"
            else
              echo "exists=false" > .circleci/${APP}.exists
            fi
      - when:
          condition:
            equal: ["false", "$(cat .circleci/<< parameters.app >>.exists | cut -d'=' -f2)" ]
          steps:
            - run:
                name: Enable BuildKit
                command: export DOCKER_BUILDKIT=1
            - run:
                name: Build image (main)
                command: |
                  set -e
                  APP="<< parameters.app >>"
                  HASH=$(cat .circleci/${APP}.hash)
                  IMAGE_BASE="ghcr.io/${CIRCLE_PROJECT_USERNAME}/${APP}"
                  docker build -f << parameters.dockerfile >> -t ${IMAGE_BASE}:main -t ${IMAGE_BASE}:sha-${HASH} .
            - run:
                name: Push sha image (cache seed)
                command: |
                  APP="<< parameters.app >>"
                  HASH=$(cat .circleci/${APP}.hash)
                  docker push ghcr.io/${CIRCLE_PROJECT_USERNAME}/${APP}:sha-${HASH}
      - run:
          name: Run container and health checks
          command: |
            set -e
            APP="<< parameters.app >>"
            docker run -d --name ${APP}-test \
              -e DISCORD_TOKEN=test \
              -e DEBUG_MODE=true \
              -e CI_SMOKE_MODE=true \
              -e CI=true \
              -e NODE_ENV=test \
              -e METRICS_PORT=3000 \
              ghcr.io/${CIRCLE_PROJECT_USERNAME}/${APP}:main
            .circleci/scripts/container_health_check.sh ${APP}-test /live 180
      - run:
          name: Snyk Container Scan (optional)
          command: |
            if [ -n "$SNYK_TOKEN" ]; then
              npm install -g snyk@latest || true
              snyk auth $SNYK_TOKEN || true
              snyk container test ghcr.io/${CIRCLE_PROJECT_USERNAME}/<< parameters.app >>:main --severity-threshold=high || true
            fi
      - run:
          name: Push main tag
          command: |
            APP="<< parameters.app >>"
            IMAGE_BASE="ghcr.io/${CIRCLE_PROJECT_USERNAME}/${APP}"
            docker push ${IMAGE_BASE}:main

  publish_latest:
    parameters:
      app:
        type: string
    machine: true
    resource_class: medium
    steps:
      - checkout
      - run:
          name: Login to GHCR
          command: |
            echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USERNAME" --password-stdin
      - run:
          name: Tag and push latest
          command: |
            APP="<< parameters.app >>"
            IMAGE="ghcr.io/${CIRCLE_PROJECT_USERNAME}/${APP}"
            docker pull ${IMAGE}:main
            docker tag ${IMAGE}:main ${IMAGE}:latest
            docker push ${IMAGE}:latest

  semantic_release:
    executor: node22
    steps:
      - checkout
      - setup_npm_cache
      - run:
          name: Run semantic-release
          command: |
            if [ -z "$CI_TOKEN" ]; then echo "CI_TOKEN not set"; exit 1; fi
            export GITHUB_TOKEN="$CI_TOKEN"
            npx semantic-release

  tag_version_images:
    machine: true
    resource_class: medium
    steps:
      - checkout
      - run:
          name: Login to GHCR
          command: |
            echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USERNAME" --password-stdin
      - run:
          name: Tag images with VERSION
          command: |
            VERSION=$(cat config/VERSION | tr -d '\n')
            for APP in bunkbot covabot djcova bluebot; do
              IMAGE="ghcr.io/${CIRCLE_PROJECT_USERNAME}/${APP}"
              docker pull ${IMAGE}:latest || true
              docker tag ${IMAGE}:latest ${IMAGE}:${VERSION}
              docker push ${IMAGE}:${VERSION}
            done

  deploy_to_unraid:
    machine: true
    resource_class: medium
    steps:
      - checkout
      - add_ssh_keys:
          fingerprints:
            - "${SSH_KEY_FINGERPRINT}"
      - setup_ssh_config
      - notify_discord:
          status: started
          version: "${CIRCLE_BRANCH}"
          message: "Deploying Starbunk services (tag: main) to Unraid server..."
      - run:
          name: Deploy to Unraid Server
          command: |
            VERSION=$(cat config/VERSION | tr -d '\n')
            DEPLOY_TAG="main"  # Use :main tag from main branch

            echo "========================================"
            echo "Deploying version: ${VERSION}"
            echo "Using image tag: ${DEPLOY_TAG}"
            echo "Target: ${PROD_SERVER_HOST}"
            echo "========================================"

            # Copy deployment script to server
            scp scripts/deployment/deploy.sh unraid-prod:/tmp/starbunk-deploy.sh
            scp scripts/deployment/health-check.sh unraid-prod:/tmp/starbunk-health-check.sh

            # Execute deployment on server
            ssh unraid-prod "bash /tmp/starbunk-deploy.sh '${PROD_DOCKER_COMPOSE_DIR}' '${DEPLOY_TAG}' '${VERSION}'"

      - run:
          name: Verify Deployment Health
          command: |
            echo "========================================"
            echo "Running post-deployment health checks..."
            echo "========================================"

            # Run health check script on server
            ssh unraid-prod "bash /tmp/starbunk-health-check.sh '${PROD_DOCKER_COMPOSE_DIR}'"

      - run:
          name: Cleanup Remote Scripts
          when: always
          command: |
            ssh unraid-prod "rm -f /tmp/starbunk-*.sh" || true

      - notify_discord:
          status: success
          version: "${CIRCLE_BRANCH}"
          message: "All services deployed and healthy on Unraid server!"

      - run:
          name: Handle Deployment Failure
          when: on_fail
          command: |
            echo "Deployment failed - Discord notification will be sent by notify_discord with when: always"

workflows:
  main_merge:
    jobs:
      - build_apps
      - docker_build_and_validate_main:
          name: build_validate_bunkbot
          app: bunkbot
          dockerfile: ./src/bunkbot/Dockerfile.ci
          requires: [build_apps]
      - docker_build_and_validate_main:
          name: build_validate_covabot
          app: covabot
          dockerfile: ./src/covabot/Dockerfile.ci
          requires: [build_apps]
      - docker_build_and_validate_main:
          name: build_validate_djcova
          app: djcova
          dockerfile: ./src/djcova/Dockerfile.ci
          requires: [build_apps]
      - docker_build_and_validate_main:
          name: build_validate_bluebot
          app: bluebot
          dockerfile: ./src/bluebot/Dockerfile.ci
          requires: [build_apps]
      - publish_latest:
          name: publish_bunkbot_latest
          app: bunkbot
          requires: [build_validate_bunkbot]
      - publish_latest:
          name: publish_covabot_latest
          app: covabot
          requires: [build_validate_covabot]
      - publish_latest:
          name: publish_djcova_latest
          app: djcova
          requires: [build_validate_djcova]
      - publish_latest:
          name: publish_bluebot_latest
          app: bluebot
          requires: [build_validate_bluebot]
      - semantic_release:
          requires:
            - publish_bunkbot_latest
            - publish_covabot_latest
            - publish_djcova_latest
            - publish_bluebot_latest
      - tag_version_images:
          requires: [semantic_release]
      - deploy_to_unraid:
          context:
            - deployment-production
          requires: [tag_version_images]
