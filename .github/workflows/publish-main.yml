name: Main - Deploy Containers

on:
  push:
    branches: [ main ]
    paths-ignore:
      - '**/*.md'
      - 'docs/**'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/PULL_REQUEST_TEMPLATE.md'
  workflow_dispatch:
    inputs:
      version:
        description: 'Semantic version (e.g., 1.2.3) to tag images with. Optional.'
        type: string
        required: false
        default: ''
      force_all:
        description: 'Force build all containers'
        type: boolean
        required: false
        default: false
      skip_validation:
        description: 'Skip validation steps (emergency deployments only)'
        type: boolean
        required: false
        default: false
      containers:
        description: 'Specific containers to deploy (comma-separated: bunkbot,djcova,starbunk-dnd,covabot)'
        type: string
        required: false
        default: ''

permissions:
  contents: read
  packages: write
  security-events: write

env:
  REGISTRY: ghcr.io
  REGISTRY_PREFIX: ghcr.io/${{ github.repository_owner }}
  NODE_VERSION: '20'

jobs:
  # ==============================================================================
  # CHANGE DETECTION & VALIDATION PIPELINE
  # ==============================================================================
  detect-changes:
    name: üîç Detect Changes
    runs-on: ubuntu-latest
    outputs:
      # Individual container changes
      shared: ${{ steps.filter.outputs.shared-src }}
      bunkbot: ${{ steps.filter.outputs.bunkbot }}
      djcova: ${{ steps.filter.outputs.djcova }}
      starbunk-dnd: ${{ steps.filter.outputs.starbunk-dnd }}
      covabot: ${{ steps.filter.outputs.covabot }}

      # Infrastructure changes
      critical-infrastructure: ${{ steps.filter.outputs.critical-infrastructure }}

      # Dynamic matrix for deployment
      deploy-matrix: ${{ steps.generate-matrix.outputs.matrix }}
      has-deployments: ${{ steps.generate-matrix.outputs.has-deployments }}

      # Rollback preparation
      previous-images: ${{ steps.prepare-rollback.outputs.previous-images }}
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: üîç Detect Path Changes
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            shared-src:
              - 'packages/shared/**'
            bunkbot:
              - 'apps/bunkbot/**'
              - 'packages/shared/**'
            djcova:
              - 'apps/djcova/**'
              - 'packages/shared/**'
            starbunk-dnd:
              - 'apps/starbunk-dnd/**'
              - 'packages/shared/**'
            covabot:
              - 'apps/covabot/**'
              - 'packages/shared/**'
            critical-infrastructure:
              - 'package.json'
              - 'package-lock.json'
              - 'tsconfig.json'
              - 'docker-compose*.yml'

      - name: üéØ Generate Dynamic Deployment Matrix
        id: generate-matrix
        run: |
          set -euo pipefail

          containers=()

          # Handle manual workflow dispatch with specific containers
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.containers }}" ]]; then
            IFS=',' read -ra MANUAL_CONTAINERS <<< "${{ github.event.inputs.containers }}"
            for container in "${MANUAL_CONTAINERS[@]}"; do
              container=$(echo "$container" | xargs) # trim whitespace
              containers+=("$container")
            done
          elif [[ "${{ github.event.inputs.force_all }}" == "true" ]]; then
            containers=("bunkbot" "djcova" "starbunk-dnd" "covabot")
          else
            # Automatic detection based on changes
            if [[ "${{ steps.filter.outputs.shared-src }}" == "true" ]]; then
              echo "üì¶ Shared package changed - deploying all containers"
              containers=("bunkbot" "djcova" "starbunk-dnd" "covabot")
            elif [[ "${{ steps.filter.outputs.critical-infrastructure }}" == "true" ]]; then
              echo "‚ö†Ô∏è Critical infrastructure changed - deploying all containers"
              containers=("bunkbot" "djcova" "starbunk-dnd" "covabot")
            else
              # Individual container changes
              [[ "${{ steps.filter.outputs.bunkbot }}" == "true" ]] && containers+=("bunkbot")
              [[ "${{ steps.filter.outputs.djcova }}" == "true" ]] && containers+=("djcova")
              [[ "${{ steps.filter.outputs.starbunk-dnd }}" == "true" ]] && containers+=("starbunk-dnd")
              [[ "${{ steps.filter.outputs.covabot }}" == "true" ]] && containers+=("covabot")
            fi
          fi

          if [[ ${#containers[@]} -eq 0 ]]; then
            echo "has-deployments=false" >> $GITHUB_OUTPUT
            echo "matrix={}" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No containers need deployment"
          else
            echo "has-deployments=true" >> $GITHUB_OUTPUT
            printf -v container_list '%s,' "${containers[@]}"
            container_list=${container_list%,}
            echo "matrix={\"container\":[$(printf '"%s",' "${containers[@]}" | sed 's/,$//')}]}" >> $GITHUB_OUTPUT
            echo "üöÄ Containers to deploy: ${container_list}"
          fi

      - name: üîÑ Prepare Rollback Information
        id: prepare-rollback
        if: steps.generate-matrix.outputs.has-deployments == 'true'
        run: |
          set -euo pipefail

          # Get current latest tags for rollback
          rollback_info="{}"

          containers=("bunkbot" "djcova" "starbunk-dnd" "covabot")
          for container in "${containers[@]}"; do
            # Get current latest tag SHA (for rollback)
            current_sha=$(docker manifest inspect ${{ env.REGISTRY_PREFIX }}/${container}:latest 2>/dev/null | jq -r '.config.digest' || echo "unknown")
            rollback_info=$(echo "$rollback_info" | jq --arg container "$container" --arg sha "$current_sha" '.[$container] = $sha')
          done

          # Compact JSON to single line for GitHub Actions output
          rollback_info_compact=$(echo "$rollback_info" | jq -c .)
          echo "previous-images=$rollback_info_compact" >> $GITHUB_OUTPUT
          echo "üìã Rollback info prepared"

  # ==============================================================================
  # COMPREHENSIVE VALIDATION SUITE
  # ==============================================================================
  validate-codebase:
    name: ‚úÖ Validate Codebase
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.has-deployments == 'true' && github.event.inputs.skip_validation != 'true'
    timeout-minutes: 15
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üì¶ Setup Node.js with Caching
        uses: ./.github/actions/setup-node-cached
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: üîç TypeScript Type Checking
        run: |
          echo "üîç Running TypeScript type checks..."
          npm run type-check
          echo "‚úÖ Type checking passed"

      - name: üé® Code Linting
        run: |
          echo "üé® Running ESLint..."
          npm run lint
          echo "‚úÖ Linting passed"

      - name: üß™ Test Suite
        run: |
          echo "üß™ Running test suite..."
          npm run test:full
          echo "‚úÖ Tests passed"

      - name: üèóÔ∏è Build Verification
        run: |
          echo "üèóÔ∏è Verifying builds..."
          npm run build:clean
          echo "‚úÖ Build verification passed"

      - name: üìä Generate Validation Report
        run: |
          echo "üìä Validation Summary:" > validation-report.txt
          echo "- TypeScript: ‚úÖ Passed" >> validation-report.txt
          echo "- Linting: ‚úÖ Passed" >> validation-report.txt
          echo "- Tests: ‚úÖ Passed" >> validation-report.txt
          echo "- Builds: ‚úÖ Passed" >> validation-report.txt
          cat validation-report.txt

  # ==============================================================================
  # SHARED PACKAGE BUILD (DEPENDENCY FOR ALL CONTAINERS)
  # ==============================================================================
  build-shared:
    name: üîß Build Shared Package
    runs-on: ubuntu-latest
    needs: [detect-changes, validate-codebase]
    if: |
      needs.detect-changes.outputs.has-deployments == 'true' &&
      (needs.detect-changes.outputs.shared == 'true' ||
       needs.detect-changes.outputs.critical-infrastructure == 'true' ||
       github.event.inputs.force_all == 'true' ||
       always())
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üì¶ Setup Node.js with Caching
        uses: ./.github/actions/setup-node-cached
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: üîß Build Shared Package
        run: |
          echo "üîß Building shared package..."
          cd packages/shared
          npm run build
          echo "‚úÖ Shared package built successfully"

      - name: üì¶ Archive Shared Build
        uses: actions/upload-artifact@v4
        with:
          name: shared-build
          path: packages/shared/dist/
          retention-days: 1

  # ==============================================================================
  # DYNAMIC CONTAINER DEPLOYMENT MATRIX
  # ==============================================================================
  deploy-containers:
    name: üöÄ Deploy ${{ matrix.container }}
    runs-on: ubuntu-latest
    needs: [detect-changes, validate-codebase, build-shared]
    if: |
      needs.detect-changes.outputs.has-deployments == 'true' &&
      (success() || github.event.inputs.skip_validation == 'true')
    timeout-minutes: 20
    strategy:
      matrix: ${{ fromJSON(needs.detect-changes.outputs.deploy-matrix) }}
      fail-fast: false
    outputs:
      deployment-status: ${{ steps.deployment.outputs.status }}
      image-digest: ${{ steps.deployment.outputs.digest }}
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üèóÔ∏è Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: network=host

      - name: üîê Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üìã Extract Container Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_PREFIX }}/${{ matrix.container }}
          tags: |
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}
            type=raw,value=v${{ github.event.inputs.version }},enable=${{ github.event_name == 'workflow_dispatch' && github.event.inputs.version != '' }}
            type=sha,prefix={{date 'YYYYMMDD-HHmmss'}}-,suffix=-{{branch}},format=short
            type=raw,value={{date 'YYYYMMDD-HHmmss'}}-{{sha}}-stable,enable=${{ github.ref == 'refs/heads/main' }}
          labels: |
            org.opencontainers.image.title=${{ matrix.container }}
            org.opencontainers.image.description=Starbunk Discord Bot - ${{ matrix.container }} container
            org.opencontainers.image.vendor=Starbunk
            deployment.timestamp=${{ github.run_id }}
            deployment.run-id=${{ github.run_id }}
            deployment.commit=${{ github.sha }}

      - name: üì¶ Download Shared Build (if needed)
        if: needs.detect-changes.outputs.shared == 'true'
        uses: actions/download-artifact@v4
        with:
          name: shared-build
          path: packages/shared/dist/

      - name: üèóÔ∏è Build and Push Container Image
        id: deployment
        uses: docker/build-push-action@v6
        with:
          context: .
          file: apps/${{ matrix.container }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64
          cache-from: |
            type=gha,scope=${{ matrix.container }}
            type=registry,ref=${{ env.REGISTRY_PREFIX }}/${{ matrix.container }}:latest
          cache-to: |
            type=gha,mode=max,scope=${{ matrix.container }}
          provenance: false
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ github.run_id }}
            DEBUG_MODE=false
            NODE_ENV=production
            LOG_LEVEL=info

      - name: üîç Container Health Verification
        run: |
          echo "üîç Verifying container health for ${{ matrix.container }}..."

          # Basic image inspection
          docker manifest inspect ${{ env.REGISTRY_PREFIX }}/${{ matrix.container }}:latest

          echo "‚úÖ Container health verification passed"

      - name: üìä Deployment Success Notification
        run: |
          echo "üéâ Successfully deployed ${{ matrix.container }}"
          echo "üì¶ Image: ${{ env.REGISTRY_PREFIX }}/${{ matrix.container }}:latest"
          echo "üîñ Digest: ${{ steps.deployment.outputs.digest }}"
          echo "‚è∞ Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"

  # ==============================================================================
  # POST-DEPLOYMENT VERIFICATION & MONITORING
  # ==============================================================================
  post-deployment-verification:
    name: ‚úÖ Verify Deployment
    runs-on: ubuntu-latest
    needs: [detect-changes, deploy-containers]
    if: needs.detect-changes.outputs.has-deployments == 'true'
    timeout-minutes: 10
    steps:
      - name: üîç Registry Verification
        run: |
          echo "üîç Verifying all deployed images in registry..."

          # Parse the deployment matrix to check each deployed container
          echo '${{ needs.detect-changes.outputs.deploy-matrix }}' | jq -r '.container[]' | while read container; do
            echo "üì¶ Checking $container..."
            if docker manifest inspect ${{ env.REGISTRY_PREFIX }}/${container}:latest >/dev/null 2>&1; then
              echo "‚úÖ ${container}:latest is available in registry"
            else
              echo "‚ùå ${container}:latest is NOT available in registry"
              exit 1
            fi
          done

      - name: üìä Generate Deployment Report
        run: |
          echo "üìä Deployment Summary Report"
          echo "=========================="
          echo "üïê Deployment Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üåø Branch: ${{ github.ref_name }}"
          echo "üë§ Triggered by: ${{ github.actor }}"
          echo ""
          echo "üöÄ Deployed Containers:"
          echo '${{ needs.detect-changes.outputs.deploy-matrix }}' | jq -r '.container[]' | while read container; do
            echo "  ‚úÖ ${container}"
          done
          echo ""
          echo "üîÑ Rollback Information:"
          echo '${{ needs.detect-changes.outputs.previous-images }}' | jq -r 'to_entries[] | "  üè∑Ô∏è \(.key): \(.value)"'

  # ==============================================================================
  # DEPLOYMENT COMPLETION
  # ==============================================================================
  deployment-complete:
    name: üéâ Deployment Complete
    runs-on: ubuntu-latest
    needs: [detect-changes, deploy-containers, post-deployment-verification]
    if: always() && needs.detect-changes.outputs.has-deployments == 'true'
    steps:
      - name: üìä Final Deployment Status
        run: |
          echo "üéâ Unified Main Branch Deployment Complete"
          echo "========================================"
          echo ""
          echo "üìä Status Summary:"
          echo "- Validation: ${{ needs.validate-codebase.result || 'skipped' }}"
          echo "- Container Deployment: ${{ needs.deploy-containers.result }}"
          echo "- Post-Verification: ${{ needs.post-deployment-verification.result }}"
          echo ""
          if [[ "${{ needs.deploy-containers.result }}" == "success" && "${{ needs.post-deployment-verification.result }}" == "success" ]]; then
            echo "üéâ Deployment completed successfully!"
            echo "üöÄ All containers are now available with :latest tags"
          else
            echo "‚ö†Ô∏è Deployment completed with issues"
            echo "üîç Check individual job logs for details"
            echo "üîÑ Consider rollback if services are affected"
          fi

      - name: üßπ Cleanup Temporary Artifacts
        run: |
          echo "üßπ Deployment artifacts are automatically cleaned up by GitHub Actions"
          echo "‚úÖ Cleanup complete"

  # ==============================================================================
  # GIT TAG MANAGEMENT
  # ==============================================================================
  tag-version:
    name: üè∑Ô∏è Tag Version
    runs-on: ubuntu-latest
    needs: [detect-changes, deploy-containers, post-deployment-verification]
    if: |
      github.ref == 'refs/heads/main' &&
      needs.detect-changes.outputs.has-deployments == 'true' &&
      needs.deploy-containers.result == 'success' &&
      needs.post-deployment-verification.result == 'success'
    permissions:
      contents: write
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üì¶ Get version from package.json
        id: get-version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "üì¶ Current version: $VERSION"

      - name: üè∑Ô∏è Create Version and Latest Git Tags
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          VERSION="${{ steps.get-version.outputs.version }}"

          echo "üè∑Ô∏è Creating git tags for version v${VERSION}"

          # Create version tag (e.g., v1.2.0)
          if git rev-parse "v${VERSION}" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è Tag v${VERSION} already exists, skipping version tag creation"
          else
            git tag "v${VERSION}" ${{ github.sha }}
            git push origin "v${VERSION}"
            echo "‚úÖ Created and pushed tag v${VERSION}"
          fi

          # Create or force-update the latest tag
          git tag -f latest ${{ github.sha }}
          git push origin latest --force
          echo "‚úÖ Updated latest tag to ${{ github.sha }}"
